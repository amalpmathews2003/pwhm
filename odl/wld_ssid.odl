/****************************************************************************
**
** SPDX-License-Identifier: BSD-2-Clause-Patent
**
** SPDX-FileCopyrightText: Copyright (c) 2022 SoftAtHome
**
** Redistribution and use in source and binary forms, with or
** without modification, are permitted provided that the following
** conditions are met:
**
** 1. Redistributions of source code must retain the above copyright
** notice, this list of conditions and the following disclaimer.
**
** 2. Redistributions in binary form must reproduce the above
** copyright notice, this list of conditions and the following
** disclaimer in the documentation and/or other materials provided
** with the distribution.
**
** Subject to the terms and conditions of this license, each
** copyright holder and contributor hereby grants to those receiving
** rights under this license a perpetual, worldwide, non-exclusive,
** no-charge, royalty-free, irrevocable (except for failure to
** satisfy the conditions of this license) patent license to make,
** have made, use, offer to sell, sell, import, and otherwise
** transfer this software, where such license applies only to those
** patent claims, already acquired or hereafter acquired, licensable
** by such copyright holder or contributor that are necessarily
** infringed by:
**
** (a) their Contribution(s) (the licensed copyrights of copyright
** holders and non-copyrightable additions of contributors, in
** source or binary form) alone; or
**
** (b) combination of their Contribution(s) with the work of
** authorship to which such Contribution(s) was added by such
** copyright holder or contributor, if, at the time the Contribution
** is added, such addition causes such combination to be necessarily
** infringed. The patent license shall not apply to any other
** combinations which include the Contribution.
**
** Except as expressly stated above, no rights or licenses from any
** copyright holder or contributor is granted under this license,
** whether expressly, by implication, estoppel or otherwise.
**
** DISCLAIMER
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
** CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
** INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
** CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
** USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
** AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
** ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
**
****************************************************************************/


%define {
    select WiFi {
	/**
	SSID configuration. Here we config the VAP interface. Name id,
	MAC address make SSID visible.

	<p>WiFi SSID table (a stackable interface object as described in
	[Section 4.2/TR-181i2]), where table entries model the MAC
	layer. A WiFi SSID entry is typically stacked on top of a Radio
	object. WiFi SSID is also a multiplexing layer, i.e. more than
	one SSID can be stacked above a single Radio. At most one entry
	in this table (regardless of whether or not it is enabled) can
	exist with a given value for Alias, or with a given value for
	Name. On creation of a new table entry, the CPE MUST choose
	initial values for Alias and Name such that the new entry does
	not conflict with any existing entries.
	At most one enabled entry in this table can exist with a given
	value for SSID, or with a given value for BSSID. </p>
	*/
	%persistent object SSID[]{
		on action add-inst call wld_ssid_addInstance_oaf;
		on action destroy call wld_ssid_delInstance_odf;
		on event "*" call wld_ssid_setConf_ocf;	
		
		/**
		 * Returns a map containing this SSID's status histogram information.
		 * The map contains:
		 * LastStatusChange: Timestamp when status changed for last time.
		 * NrStatusChanges: Number of times status changed.
		 * StatusHistogram: String of comma separated values, containing seconds how long interface has spent in that state
		 * LastStatusHistogramUpdate
		 * LastEnableTime: The timestamp of the last time that radio was set to enable.
		 * LastDisableTime: The timestamp of the last time that radio was set to disable.
		 * NrEnables: The number of times Enable has been set to true (so only false to true is counted)
		 */
		htable getStatusHistogram();

		/**
		 * <p>The current operational state of the SSID entry (see
		 * [Section 4.2.2/TR-181i2]). Enumeration of: </p>
		 * <ul>
		 *     <li> Up</li>
		 *     <li> Down</li>
		 *     <li> Unknown</li>
		 *     <li> Dormant</li>
		 *     <li> NotPresent</li>
		 *     <li> LowerLayerDown</li>
		 *     <li> Error(OPTIONAL)</li>
		 * </ul>
		 * <p>When Enable is false then Status SHOULD normally be Down
		 * (or NotPresent or Error if there is a fault condition on the
		 * interface). When Enable is changed to true then Status SHOULD
		 * change to Up if and only if the interface is able to transmit
		 * and receive network traffic; it SHOULD change to Dormant if
		 * and only if the interface is operable but is waiting for
		 * external actions before it can transmit and receive network
		 * traffic (and subsequently change to Up if still operable when
		 * the expected actions have completed); it SHOULD change to
		 * LowerLayerDown if and only if the interface is prevented from
		 * entering the Up state because one or more of the interfaces
		 * beneath it is down; it SHOULD remain in the Error state if
		 * there is an error or other fault condition detected on the
		 * interface; it SHOULD remain in the NotPresent state if the
		 * interface has missing (typically hardware) components; it
		 * SHOULD change to Unknown if the state of the interface can
		 * not be determined for some reason. </p>
		 */
		%read-only string Status{
			on action validate call check_enum ["Up","Down","Unknown","Dormant","NotPresent","LowerLayerDown","Error"];
			default "Down";
		}
		
		/**
		 * Timestamp of the last time status changed.
		 */
		%read-only datetime LastStatusChangeTimeStamp;
		
		/**
		 * <p>A non-volatile handle used to reference this instance.
		 * Alias provides a mechanism for an ACS to label this
		 * instance for future reference. An initial unique value MUST
		 * be assigned when the CPE creates an instance of this
		 * object.</p> */
		%persistent %unique %key string Alias;
		
		/**
		 * Configurable instance alias to be used for higher layers.
		 */
		%persistent %protected string CustomAlias;

		/**
		 * <p> The textual name of the SSID entry as assigned by the
		 * CPE.</p> */
		%read-only string Name;

		/**
		 * Description of the SSID.
		 * Ex: "Guest SSID"
		 */
		%persistent %protected string Description {
			userflags %upc;
		}
		

		/**
		 * The role this SSID is fulfilling the the MLDSta.
		 * Possible options:
		 * * None: The SSID does not have a Role in the MLD, i.e. the SSID is not supporting MLO, or the SSID is
		 *    currently not actively either trying to connect or connecting.
		 * * Primary: The SSID represents the Primary MLO SSID interface. This is the interface that should be used for connection management.
		 *    When connected over MLO, this linux interface that will be used for traffic.
		 * * Aux: The SSID is an auxiliary MLO SSID interface. This interface should not be used for connection management.
		 *    For connections over MLO, this SSID linux interface shall not transmit or receive any traffic, but instead will be handled through
		 *    the main SSID linux interface. 
		 *    In case of Endpoints, on active MLO connections, there will only be traffic on the Primary interface, and not on Auxiliary.
		 *    In case of AccessPoints, MLO stations shall be added to the Primary AccessPoint as AssociatedDevice, and the traffic of
		 *    these station shall only use the primary interface, and not any Auxiliary interface. Note that this does not apply
		 *    for stations not doing MLO.
		 * 
		 */
		%read-only string MLDRole {
			on action validate call check_enum ["None", "Primary", "Auxiliary"];
			default "None";
		}

		/** 
		 * The link ID of this SSID in active MLO connections.
		 * If this SSID is not actively part of an MLD, this value shall be -1.
		 *
		 * For Endpoints, when MLDRole is not NA, and ConnectionStatus is Connected, it may still occur that MLDLinkId is -1. 
		 * In this case the SSID is likely associated as a "Single Link", even though configured as MLO capable. 
		 * It is thus not part of an active MLDSta. 
		 * The Status of the SSID shall be Up, and this Endpoint Linux interface will still handle traffic.
		 */
		%read-only int16 MLDLinkID {
			on action validate call check_range { min = -1, max = 14 };
			default -1;
		}
		

		/**
		 * Custom netdev interface name:
		 * when allowed and filled, it overrides the auto generated interface name
		 */
		%persistent %protected string CustomNetDevName;
		
		/**
		 * <p>The accumulated time in seconds since the SSID entered
		 * its current operational state.</p> */
		%read-only uint32 LastChange {
			on action read call wld_ssid_getLastChange_prf;
		}
		/**
		 * <p> Comma-separated list (maximum length 1024) of strings.
		 * Each list item MUST be the path name of an interface object
		 * that is stacked immediately below this interface object. If
		 * the referenced object is deleted, the corresponding item MUST
		 * be removed from the list.</p> */
		%persistent string LowerLayers{
			on action write call set_object_ref_simple;
			on action write call wld_ssid_setLowerLayers_pwf;
		}
		
		/* Network device Index */
		%read-only uint32 Index;
		
		/**
		 * <p>[MACAddress] The Basic Service Set ID.</p>
		 * <p>This is the MAC address of the access point, which can
		 * either be local (when this instance models an access point
		 * SSID) or remote (when this instance models an end point
		 * SSID). </p> */
		%persistent %read-only string BSSID;
		
		/**
		 * <p>[MACAddress] The MAC address of this interface.</p>
		 * <p>If this instance models an access point SSID, MACAddress is
		 * the same as MACAddress. Note: This is not necessarily the
		 * same as the Ethernet header source or destination MAC
		 * address, which is associated with the IP interface and is
		 * modeled via the Ethernet.Link.{i}.MACAddress parameter. </p>
		 */
		%persistent string MACAddress{
			on action validate call is_valid_macaddr;
		}
		/**
		 *  <p> The current service set identifier in use by the
		 *  connection. The SSID is an identifier that is attached to
		 *  packets sent over the wireless LAN that functions as an ID
		 *  for joining a particular radio network (BSS).</p>
		 */
		%persistent string SSID{
			on action validate call wld_ssid_validateSSID_pvf;
			default "SSID_NOT_SET";
			userflags %usersetting;
		}
		
		/**
		 * MLD-BSS unit number specifying BSS across multiple radios that 
		 * form a single Multi Link Device. Assigning the same MLD unit groups
		 * Basic Service Sets (BSS) across radios. A (default) value of -1 indicates 
		 * that the interface is not part of any MLD.
		 */
		%persistent int32 MLDUnit{
		    default -1;
		}

		%read-only object Stats{
			on action read call wld_ssid_getStats_orf;

			/** The total number of bytes transmitted out of the
			 *  interface, including framing characters. */
			%volatile %read-only uint64 BytesSent;

			/** The total number of bytes received on the interface,
			 *  including framing characters. */
			%volatile %read-only uint64 BytesReceived;

			/** The total number of packets transmitted out of the
			 *  interface. */
			%volatile %read-only uint64 PacketsSent;

			/** The total number of packets received on the interface. */
			%volatile %read-only uint64 PacketsReceived;
			/** The total number of outbound packets that could not be
			 *  transmitted because of errors. */
			%volatile %read-only uint32 ErrorsSent;

			/** The total number of transmitted packets which were retransmissions. 
			 *  Two retransmissions of the same packet results in this counter incrementing by two. */
			%read-only uint32 RetransCount;

			/** The total number of inbound packets that contained errors
			 *  preventing them from being delivered to a higher-layer
			 *  protocol.*/
			%volatile %read-only uint32 ErrorsReceived;

			/** The total number of packets requested for transmission which
			 *  were not addressed to a multicast or broadcast address at
			 *  this layer, including those that were discarded or not
			 *  sent.*/
			%volatile %read-only uint32 DiscardPacketsSent;

			/** The total number of inbound packets which were chosen to be
			 *  discarded even though no errors had been detected to prevent
			 *  their being delivered. One possible reason for discarding
			 *  such a packet could be to free up buffer space.*/
			%volatile %read-only uint32 DiscardPacketsReceived;

			/** The total number of packets that higher-level protocols
			 *  requested for transmission and which were addressed to a
			 *  multicast address at this layer, including those that were
			 *  discarded or not sent.*/
			%volatile %read-only uint32 UnicastPacketsSent;

			/** The total number of received packets, delivered by this
			 *  layer to a higher layer, which were not addressed to a
			 *  multicast or broadcast address at this layer.*/
			%volatile %read-only uint32 UnicastPacketsReceived;
			
			/** The total number of outbound packets which were chosen to be
			 *  discarded even though no errors had been detected to prevent
			 *  their being transmitted. One possible reason for discarding
			 *  such a packet could be to free up buffer space.*/
			%volatile %read-only uint32 MulticastPacketsSent;

			/** The total number of received packets, delivered by this
			 *  layer to a higher layer, which were addressed to a
			 *  multicast address at this layer.*/
			%volatile %read-only uint32 MulticastPacketsReceived;

			/** The total number of packets that higher-level protocols
			 *  requested for transmission and which were addressed to a
			 *  broadcast address at this layer, including those that were
			 *  discarded or not sent.*/
			%volatile %read-only uint32 BroadcastPacketsSent;
			
			/** The total number of received packets, delivered by this
			 *  layer to a higher layer, which were addressed to a
			 *  broadcast address at this layer. */
			%volatile %read-only uint32 BroadcastPacketsReceived;

			/** The total number of packets received via the interface which
			 *  were discarded because of an unknown or unsupported
			 *  protocol.*/
			%volatile %read-only uint32 UnknownProtoPacketsReceived;

			/** The number of packets that were not transmitted successfully
			 *  due to the number of retransmission attempts
			 *  exceeding an 802.11 retry limit.*/
			%volatile %read-only uint32 FailedRetransCount;

			/** The number of packets that were successfully transmitted after one or more retransmissions*/
			%volatile %read-only uint32 RetryCount;

			/** The number of packets that were successfully transmitted after more than one retransmission*/
			%volatile %read-only uint32 MultipleRetryCount;

			/** The total number of packets that higher-level protocols
			 *  requested for transmission ordered by wmm category*/
			%volatile %read-only object WmmPacketsSent {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}

			/** The total number of packets that higher-level protocols
			 *  requested for transmission, but failed to be sent ordered by wmm category*/
			%volatile %read-only object WmmFailedSent {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}

			/** The total number of packets received on this interface ordered by wmm category*/
			%volatile %read-only object WmmPacketsReceived {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}

			/** The total number of packets received on this interface, but failed to be sent to the
					higher layers, ordered by wmm category*/
			%volatile %read-only object WmmFailedReceived {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}

			/** The total number of bytes that higher-level protocols
			 *  requested for transmission ordered by wmm category*/
			%volatile %read-only object WmmBytesSent {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}

			/** The total number of bytes that higher-level protocols
			 *  requested for transmission, but failed to be sent ordered by wmm category*/
			%volatile %read-only object WmmFailedbytesSent {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}

			/** The total number of bytes received on this interface ordered by wmm category*/
			%volatile %read-only object WmmBytesReceived {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}

			/** The total number of bytes received on this interface, but failed to be sent to the
					higher layers, ordered by wmm category*/
			%volatile %read-only object WmmFailedBytesReceived {
				%volatile %read-only uint32 AC_BE;
				%volatile %read-only uint32 AC_BK;
				%volatile %read-only uint32 AC_VO;
				%volatile %read-only uint32 AC_VI;
			}
		}

		/**
		 *  Packets statistics per SSID
		 */
		htable getSSIDStats();

		/**
		 * Enables or disables the SSID entry.  */
		%persistent bool Enable{
			default false;
		}
	} /* object SSID */
    }
}

