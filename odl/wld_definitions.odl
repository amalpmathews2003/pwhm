/****************************************************************************
**
** SPDX-License-Identifier: BSD-2-Clause-Patent
**
** SPDX-FileCopyrightText: Copyright (c) 2022 SoftAtHome
**
** Redistribution and use in source and binary forms, with or
** without modification, are permitted provided that the following
** conditions are met:
**
** 1. Redistributions of source code must retain the above copyright
** notice, this list of conditions and the following disclaimer.
**
** 2. Redistributions in binary form must reproduce the above
** copyright notice, this list of conditions and the following
** disclaimer in the documentation and/or other materials provided
** with the distribution.
**
** Subject to the terms and conditions of this license, each
** copyright holder and contributor hereby grants to those receiving
** rights under this license a perpetual, worldwide, non-exclusive,
** no-charge, royalty-free, irrevocable (except for failure to
** satisfy the conditions of this license) patent license to make,
** have made, use, offer to sell, sell, import, and otherwise
** transfer this software, where such license applies only to those
** patent claims, already acquired or hereafter acquired, licensable
** by such copyright holder or contributor that are necessarily
** infringed by:
**
** (a) their Contribution(s) (the licensed copyrights of copyright
** holders and non-copyrightable additions of contributors, in
** source or binary form) alone; or
**
** (b) combination of their Contribution(s) with the work of
** authorship to which such Contribution(s) was added by such
** copyright holder or contributor, if, at the time the Contribution
** is added, such addition causes such combination to be necessarily
** infringed. The patent license shall not apply to any other
** combinations which include the Contribution.
**
** Except as expressly stated above, no rights or licenses from any
** copyright holder or contributor is granted under this license,
** whether expressly, by implication, estoppel or otherwise.
**
** DISCLAIMER
**
** THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
** CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
** INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
** DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
** CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
** LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
** USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
** AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
** ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
** POSSIBILITY OF SUCH DAMAGE.
**
****************************************************************************/

/**
   WIFI object is generated plugin based to tr181-Issue2 spec.
   On some places we've add extra config parameters (extra data
   fields for driver or GUI). This WIFI object provides global
   access to the WiFi driver and is split in 4 separate objects.
   \n<B>RADIO</B>
   \n<B>AccessPoint</B>
   \n<B>SSID</B>
   \n<B>EndPoint</B>
*/
%define {
%persistent object WiFi {
	/* Functions - used in NeMo for creating and deleting VAP interfaces (USE WITH CARE) */

	/**
	 * Creates a VAP interface on the RADIO and updates the
	 * AccessPoint and SSID object fields.
	 * @param vap Name of the VAP interface that will be created
	 *        (wl0,wl1,...)
	 * @param radio Name of the RADIO interface that derrives the
	 *        vap interface. (wifi0, wifi1,...)
	 * @return Success if &gt;=0, the value represents the
	 *         NETFINDEX. When 0 it's representing an error number.
	 */
	uint32 addVAPIntf(%in %mandatory string vap, %in %mandatory string radio); /* use WIFI_addVAPIntf */
	/**
	 * Delete a VAP interface from the physical radio interface.
	 * Update also AccessPoint and SSID object fields. Before this
	 * can be done, the (deleted) interface must be down. You don't
	 * need to know which Radio object it's attached.
	 * @param vap Name of the VAP interface that will be removed
	 *        from the system.
	 * @return If &lt;0 it's representing an error.
	 * &gt;=0 is success.
	 */
	uint32 delVAPIntf(%in %mandatory string vap);               /* use WIFI_delVAPIntf */

	/**
	 * Creates an EndPoint interface on the RADIO and updates the
	 * EndPoint and SSID object fields.
	 * @param radio Name of the RADIO interface that derrives the
	 *        endpoint interface. (wifi0, wifi1,...)
	 * @param endpoint Name of the EndPoint interface that will be created
	 *        (wl0,wl1,...)
	 * @return Success if &gt;=0, the value represents the
	 *         NETFINDEX. When 0 it's representing an error number.
	 * @version 6.1
	 */
	uint32 addEndPointIntf(%in %mandatory string radio, %in %mandatory string endpoint);
	/**
	 * Delete an EndPoint interface from the physical radio interface.
	 * Update also EndPoint and SSID object fields. Before this
	 * can be done, the (deleted) interface must be down. You don't
	 * need to know which Radio object it's attached.
	 * @param endpoint Name of the EndPoint interface that will be removed
	 *        from the system.
	 * @return If &lt;0 it's representing an error.
	 * &gt;=0 is success.
	 * @version 6.1
	 */
	uint32 delEndPointIntf(%in %mandatory string endpoint);


	/**
	 * <b>For debug use only... VALUES ARE BIT OFFSETS (1 &lt;&lt;
	 * bitnr). List of current 'bitnr':</b>
	 * <li>00 - Disable the VAP interface</li>
	 * <li>01 - Get IWList info? - Not needed!</li>
	 * <li>02 - Get IWPriv info? - Not needed!</li>
	 * <li>03 - Get IWConfig info? - Not needed!</li>
	 * <li>04 - Get current VAP SSID from driver</li>
	 * <li>05 - Current WPS state (if WPS enabled)</li>
	 * <li>06 - Set SSID (also hide SSID)</li>
	 * <li>07 - Stops HostAPD</li>
	 * <li>08 - Set AutoChannel (BCM does it differently)</li>
	 * <li>09 - Set a FIX Channel</li>
	 * <li>10 - Set the security mode (WEP/WPA(2)/Mixed)</li>
	 * <li>11 - Set WPS mode (PBC/Client/Self-Pin)</li>
	 * <li>12 - Set a IWPriv command? - Not Needed!</li>
	 * <li>13 - Change the security key (WEP/WPA(2)/Mixed)</li>
	 * <li>14 - Change WMM parameters</li>
	 * <li>15 - Set a different BAND (also Channel related)</li>
	 * <li>16 - Reconfigure HostAPD parameters</li>
	 * <li>17 - Start HostAPD (This needs also a HostAPD_STOP)</li>
	 * <li>18 - Reconfigure HostAPD</li>
	 * <li>19 - Set VAP interface inline with enable state</li>
	 * <li>20 - Get the Channel</li>
	 * <li>21 - Trigger WPS button</li>
	 */
	uint32 FSM_Start(%in string vap, %in uint32 bitnr);  /* use WIFI_FSM_Start (DEBUG) */

	/**
	 *  <p><b>OBSOLETE - Use the NeMo MIB interface to control this</b></p>
	 *  Enable/Disable a VAP interface
	 *  @param vap Name of the VAP interface that will updated. Required input field.
	 *  @param state 1 or 0, active or disable state. Use -1 for getting the current state.
	 *  The other states: Unknown, Dormant, NotPresent, LowerLayerDown or Error
	 *  can't be set with this function.
	 *  @return It will return the current state after the action.
	 */
//	bool activateVAPIntf(%in string vap, %in bool state);

	/**
	 *  <p><b>OBSOLETE - Use the NeMo MIB interface to control this</b></p>
	 *  Enable/Disable a Radio interface, note this will disable also the upper VAPs
	 *  @param radio Name of the Radio interface that will updated. Required input field.
	 *  @param state 1 or 0, active or disable state. Use -1 for getting the current state.
	 *  The other states: Unknown, Dormant, NotPresent, LowerLayerDown or Error
	 *  can't be set with this function.
	 *  @return It will return the current state after the action.
	 */
//	bool activateRADIOIntf(%in string radio, %in bool state);

	/* For the WEB GUI ((Better NOT)) --> GUI guys must talk with (practical) DRIES or Theory (Wouter)!!! */
	/*
		NeMo will take care of the configuration, so it's NeMo that will save the config
		Those functions can be used (debug). But in the future they will be obsolete.
	*/
	/**
	 * <p><b>OBSOLETE - Use the NeMo MIB interface to control this</b></p>
	 * Gets data from a registered VAP interface and updates the
	 * requested fields with AccessPoint and SSID object data.
	 * @param vap - Name of the VAP interface that will be read.
	 *  	  (wl0,wl1,...) Required input field.
	 * @param enable after the call this will be updated with the current 'enable' state
	 * of the vap.
	 * @param ssid after the call this will be updated with the current 'SSID' name
	 * of the VAP. (copied from SSID.&#123;vap&#125; object.
	 * @param hideSSID after the call this will be updated with the current
	 * 'SSIDAdvertisementEnabled' value.
	 * @param secKey after the call this will be updated with the security key used.
	 * Attention, when the secMode is WEP, it will contain the WEP key.
	 * When it's WPA(2) it can be the passphrase or TKIP key.
	 * It's an empty string when security is set on none.
	 * @param secMode after the call this will be updated with the selected security mode.
	 * (None, WEP-64, WEP-128, WPA-Personal, WPA2-Personal, WPA-WPA2-Personal, WPA-Enterprise,
	 * WPA2-Enterprise or WPA-WPA2-Enterprise.
	 * @return Success if &gt;=0!. When &lt;0 it's representing a failure.
	 */
//	bool getWebVAPData(string vap, bool enable, string ssid, bool hideSSID, string secKey, string secMode, string encrypMode);

	/**
	 * <p><b>OBSOLETE - Use the NeMo MIB interface to control this</b></p>
	 * Sets data on a registered VAP interface and updates the
	 * requested fields in the object AccessPoint and SSID data.
	 * @param vap - Name of the VAP interface that will be updated.
	 *  	  (wl0,wl1,...) Required input field.
	 * @param enable after the call the active vap will be updated with the requested 'enable' state.
	 * @param ssid after the call, the vap SSID will be updated with the requested SSID.
	 * @param hideSSID after the call the SSID will be actively broadcasted or not.
	 * @param secKey after the call this will be updated with the security key used.
	 * Attention, this is based on the given secMode value. When this is WEP,
	 * it must contain a valid WEP key.  When it's WPA(2) it must contain a passphrase
	 * or TKIP key. When 'none' the value isn't taken.
	 * @param secMode after the call the security mode will be updated. Possible values:.
	 * (None, WEP-64, WEP-128, WPA-Personal, WPA2-Personal, WPA-WPA2-Personal, WPA-Enterprise,
	 * WPA2-Enterprise or WPA-WPA2-Enterprise).
	 * @return Success if &gt;=0!. When &lt;0 it's representing a failure.
	 */
//	bool setWebVAPData(%in string vap, %in bool enable, %in string ssid, %in bool hideSSID, %in string secKey, %in string secMode, %in string encrypMode);

	/**
	 * <p><b>OBSOLETE - Use the NeMo MIB interface to control this</b></p>
	 * Gets main Radio data
	 * @param radio Name of the Radio interface that will be read. Needed input field.
	 * @param After the call this will contain Current 'Enable' state of
	 * the selected Radio interface (Up/Down).
	 * @param selectchannel After the call this will contain the cached channel.
	 * In case this is 0 it means Auto Channel selection.
	 * @param channel After the call this will contain the used channel by the Radio.
	 * @return Success if &gt;=0!. When &lt;0 it's representing a failure.
	*/
//	bool getWebRadioData(%in string radio, %in string mode, %in uint16 selectchannel, %in uint16 channel);

	/**
	 * <p><b>OBSOLETE - Use the NeMo MIB interface to control this</b></p>
	 * Sets main Radio data
	 * @param radio Name of the Radio interface that will be read. Needed input field.
	 * @param mode After the call this will set Current 'Enable' state of
	 * the selected Radio interface (Up/Down).
	 * @param selectchannel After the call this will set the current channel.
	 * In case this is 0 it means Auto Channel selection.
	 * @return Success if &gt;=0!. When &lt;0 it's representing a failure.
	*/
//	bool setWebRadioData(%in string radio, %in string mode, %in uint16 selectchannel);

// bool getWebWPSData(%in string vap, %in bool enable, %in string wpsMode, %in string wpsClientPin, %in string wpsSelfPin);
// bool setWebWPSData(%in string vap, %in bool enable, %in string wpsMode, %in string wpsClientPin);

	/**
	 * This command defines access to other WiFi SSIDs that this device is able to receive.
	 * It is defined in TR181 usp 2.12 and it triggers neighboring SSID scan on all available radios
	 * @return htable including:
	 * "Status" of the the request, which is one of the following strings:
	 * Canceled, Complete, Error
	 * And "Result" list with all detected neighbout SSIDs on all available radios
	 */
	htable NeighboringWiFiDiagnostic();

/* /////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////// */

	/**
	 * Verifies WPS PIN Checksum. Stips out Dash and Whitespace before checking.
	 * @param StrVal string representing the PIN
	 * @return True if PIN OK, False if any error occours
	 */
	bool checkWPSPIN(%in string PIN);

	/**
	   Global WPS system string parameters (Used in IE of the Beacon
	   and Response frame). These fields are filled in at startup
	   time and taken from the _ENV.&lt; Vendor / software / version
	   / ...&gt; board settings.
	*/
	object wps_DefParam{         /* Some used driver defines copied on all active WPS intf */
		/** 8-digit format WPS pin (Self PIN) */
		string DefaultPin;
		/** Device name */
		string DevName;
		/** Device OUI */
		string OUI;
		/** Device friendly name */
		string FriendlyName;
		/** Manufacture Name  */
		string Manufacturer;
		/** Manufacture URL link */
		string ManufacturerUrl;
		/** Full model description */
		string ModelDescription;
		/** Vendor name  */
		string ModelName;
		/** Vendor number */
		string ModelNumber;
		/** Vendor URL link */
		string ModelUrl;
		/** OS version ID (A.B.C.D) */
		string OsVersion;
		/** Serial number (partly) */
		string SerialNumber;
		/** WPS UUID */
		string UUID;
		/** WPS Supported Version */
		int32 wpsSupVer;
		/** Share WPS UUID at vendor plugin */
		int32 wpsUUIDShared;

		/** <B>DEBUG</B> Generate a new SelfPIN and update the
		 *  DefaultPin field */
		uint32 wps_GenSelfPIN();
	}

/* /////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////// */

	/**
	 * Auto commit manager.
	 * This component will manage the auto commit feature, where changes in the data model
	 * will automatically cause a commit to happen.
	 *
	 * @version 10.2
	 */
	%persistent object AutoCommitMgr{
		on event "*" call wld_autoCommitMgr_setConf_ocf;
	
		/**
		 * Whether auto committing should be enabled
		 */
		%persistent bool Enable{
			default 0;
		}
		
		/**
		 * The time in milliseconds between when the first change happens that triggers the fsm,
		 * and triggering the commit.
		 * Note that due to timer restrictions, timers less then 100ms will be rounded up to 100ms.
		 */
		%persistent uint32 DelayTime{
			default 250;
		}
		
		/**
		 * Ensure that first commit will only happen BootDelayTime ms after
		 * the component got initialized, to avoid potential clashes.
		 */
		%persistent uint32 BootDelayTime{
			default 4000;
		}
		
		htable debug(%in string op);
	}
    }
}

include "wld_radio.odl";
include "wld_ssid.odl";
include "wld_accesspoint.odl";
include "wld_endpoint.odl";

%populate {
	on event "app:start" call app_start;
	on event "dm:instance-added" call wld_radio_addInstance_ocf
		filter 'path == "WiFi.Radio."';
	on event regexp("dm:object-(added|changed)") call wld_rad_setVendorData_ocf
		filter 'path matches "WiFi\.Radio\.[0-9]+\.Vendor\.+"';
	on event "dm:object-changed" call wld_rad_setOperatingClass
		filter 'path matches "WiFi\.Radio\.[0-9]+\." && (contains("parameters.OperatingChannelBandwidth") || contains("parameters.Channel"))';
	on event "dm:object-changed" call wld_rad_updatePossibleChannels_ocf
		filter 'path matches "WiFi\.Radio\.[0-9]+\." && (contains("parameters.OperatingFrequencyBand") || contains("parameters.RegulatoryDomain"))';
}

/** @location sah_lib_wld /wld.odl */
